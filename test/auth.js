'use strict';

const jwt = require('jsonwebtoken'),
      path = require('path'),
      should = require('should'),
      sinon = require('sinon');

const agentFactory = require('./agent'),
      config = require(path.resolve('./config')),
      db = require('./db');

describe('authentication', () => {
  let agent,
      dbData,
      sandbox,
      // unverifiedAdmin,
      unverifiedUser,
      // verifiedAdmin,
      verifiedUser;

  beforeEach(() => {
    agent = agentFactory();
  });

  beforeEach(() => {
    sandbox = sinon.sandbox.create();
    sandbox.useFakeTimers({
      now: 1500000000000,
      toFake: ['Date']
    });

    sandbox.stub(config.jwt, 'expirationTime').value(1000);
    sandbox.stub(config.jwt, 'secret').value('asdf');
  });

  afterEach(() => {
    sandbox.restore();
  });

  // fill database with some data
  beforeEach(async () => {
    dbData = await db.fill({
      users: 4,
      verifiedUsers: [0, 2],
      admins: [2, 3]
    });

    [verifiedUser, unverifiedUser/* , verifiedAdmin, unverifiedAdmin*/] = dbData.users;
  });

  describe('GET /auth/token', () => {
    context('valid request', () => {

      it('[verified user] respond with 200 and valid jwt token', async () => {
        const response = await agent
          .get('/auth/token')
          .auth(verifiedUser.username, verifiedUser.password)
          .expect(200);

        // check token (generated by jwt.io)
        const { token } = response.body.meta;
        should(token).eql('eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6InVzZXIwIiwidmVyaWZpZWQiOnRydWUsImlhdCI6MTUwMDAwMDAwMCwiZXhwIjoxNTAwMDAxMDAwfQ.XRjFECsPRTGvXHHgUgtVmM3JkDAJN8uYc30AQR9MPxY');

        // check payload
        const payload = jwt.decode(token);
        should(payload).deepEqual({
          username: verifiedUser.username,
          verified: true,
          iat: 1500000000,
          exp: 1500001000
        });
      });

      it('[unverified user] respond with 200 and valid jwt token', async () => {
        const response = await agent
          .get('/auth/token')
          .auth(unverifiedUser.username, unverifiedUser.password)
          .expect(200);

        // check token (generated by jwt.io)
        const { token } = response.body.meta;
        should(token).eql('eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6InVzZXIxIiwidmVyaWZpZWQiOmZhbHNlLCJpYXQiOjE1MDAwMDAwMDAsImV4cCI6MTUwMDAwMTAwMH0.qFND2GTE16SBnqieLX0WpOOUU_q9D9XdT0U3myO047M');

        // check payload
        const payload = jwt.decode(token);
        should(payload).deepEqual({
          username: unverifiedUser.username,
          verified: false,
          iat: 1500000000,
          exp: 1500001000
        });

      });

    });

    context('invalid request', () => {
      it('[incorrect password] 401 invalid credentials', async () => {
        const response = await agent
          .get('/auth/token')
          .auth(verifiedUser.username, 'incorrectPassword')
          .expect(401);

        should(response.body).have.property('errors').deepEqual([
          { title: 'Not Authorized', detail: 'invalid credentials' }
        ]);
      });

      it('[nonexistent username] 401 invalid credentials', async () => {
        const response = await agent
          .get('/auth/token')
          .auth('nonexistent-user', 'xiy1A.0n.;SxXio')
          .expect(401);

        should(response.body).have.property('errors').deepEqual([
          { title: 'Not Authorized', detail: 'invalid credentials' }
        ]);
      });

      it('[missing authorization header] 401 missing credentials', async () => {
        const response = await agent
          .get('/auth/token')
          .expect(401);

        should(response.body).have.property('errors').deepEqual([
          { title: 'Not Authorized', detail: 'invalid or missing Authorization header' }
        ]);
      });

      it('[not Basic authorization header] 401 ', async () => {
        const response = await agent
          .get('/auth/token')
          .set('Authorization', 'Bearer aaaa.bbbb.cccc')
          .expect(401);

        should(response.body).have.property('errors').deepEqual([
          { title: 'Not Authorized', detail: 'invalid or missing Authorization header' }
        ]);
      });

    });
  });

  /*
  describe('GET /auth/token/admin', () => {
    context('valid request', () => {

      it('[admin with verified email] 200 and valid jwt admin token', async () => {
        // admin token has small expiration time
        // and admin: true in payload
        const response = await agent
          .get('/auth/token/admin')
          .auth(verifiedAdmin.username, verifiedAdmin.password)
          .expect(200);

        // check token (generated by jwt.io)
        const { token } = response.body.meta;
        should(token).eql('');

        // check payload
        const payload = jwt.decode(token);
        should(payload).deepEqual({
          username: verifiedAdmin.username,
          verified: true,
          admin: true,
          iat: 1500000000,
          exp: 1500000500
        });
      });

      it('[admin with unverified email] 401 not verified');

      it('[not admin] 401 not admin');
    });
  });
  */
});

describe('authorization', () => {

});
